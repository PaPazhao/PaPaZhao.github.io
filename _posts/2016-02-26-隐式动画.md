---
layout: post
title: 隐式动画
date: 2016-02-16 15:32:24.000000000 +09:00
tags: 分类1
---
# 隐式动画
当你改变CALayer的一个动画属性的值，这个改变不会立刻在屏幕上展示出来，而是从先前的值平滑过渡到新的值。这个动画过程我们并没有指定任何动画的类型仅仅是改变了一个属性的值而已，这就是隐式动画。
    
- **动画执行时间取决于当前事务的设置**   
- **动画类型取决于图层行为**  
- 动画不需要再`Core Animation`中手动打开，但是需要明确的关闭，否则他会一直存在  


下面这个例子展示了一个修改背景颜色的隐式动画，当修改了`self.colorLayer.backgroundColor` 的颜色后有一个过渡的动画效果。

```
class ViewController: UIViewController {
 
    var colorLayer: CALayer!
    
    @IBOutlet weak var layerView: UIView!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.colorLayer = CALayer()
        self.colorLayer.frame = CGRect(x: 50, y: 50, width: 100, height: 100)
        self.colorLayer.backgroundColor = UIColor.blue.cgColor
        
        self.layerView.layer.addSublayer(self.colorLayer)
    }

    @IBAction func changeColor(_ sender: Any) {
        let red = CGFloat(arc4random_uniform(255)) / 256
        let green = CGFloat(arc4random_uniform(255)) / 256
        let blue = CGFloat(arc4random_uniform(255)) / 256
        
        self.colorLayer.backgroundColor = UIColor(red: red, green: green, blue: blue, alpha: 1).cgColor 
    }
}

```

那么`Core Animation`是如何判断动画的类型和执行时间呢？下一节给出详细解释。


## 事务

事务实际上是`Core Animation`用来包含一系列属性动画集合的机制，任何用指定事务去改变可以做动画的图层属性都不会立刻发生变化，而是当事务一旦提交的时候 开始用一个动画过渡到新值。  

事务是通过 `CATransaction` 类来做管理，这个类管理了你不能访问的事务。 没有属性或者实例方法，并且也不能创建实例。但是可以用 `begin` 和 `commit` 分别来入栈或者出栈。

任何可以做动画的图层属性都会被添加到栈顶的事务，你可以通过 `setAnimationDuration` 方法设置当前事务的动画时间，或者通过 `animationDuration` 方法来获取值(默认0.25秒)。

下面这个例子展示了通过事务开启一个隐式动画:  

```
@IBAction func changeColor(_ sender: Any) {

    CATransaction.begin()
    CATransaction.setAnimationDuration(1)
    
    let red = CGFloat(arc4random_uniform(255)) / 256
    let green = CGFloat(arc4random_uniform(255)) / 256
    let blue = CGFloat(arc4random_uniform(255)) / 256
    
    self.colorLayer.backgroundColor = UIColor(red: red, green: green, blue: blue, alpha: 1).cgColor
    CATransaction.commit()
}
```

这个例子中我们创建了一个新的事务，于是修改时间就不会有副作用.  
> 因为修改当前事务的时间可能会导致同一时刻别的动画，最好还是在调整动画前压入一个新的事务。


`Core Animation在`每个`run loop`周期中自动开始一次新的事务，即使你不显式的用 `CATransaction.begin()` 开始一次事务，任何在一次 `run loop` 循环中属性 的改变都会被集中起来，然后做一次 0.25秒 的动画。

 
  
如果你用过的动画方法做过一些动画效果，那么应该对这个模式不陌生。 有两个方法
  
```
open class func beginAnimations(_ animationID: String?, context: UnsafeMutableRawPointer?)  
open class func commitAnimations()  
```
  
这两个方法其实在底层都是通过事务类`CATransaction`来实现的


## 完成块
基于 `UIView` 的 `Block` 动画允许你在动画结束的时候执行一个完成的动作. `CATransaction` 接口提供的 `CATransaction.setCompletionBlock` 方法也有同样的功能。


在颜色动画完成之后添加一个回调:

```
    @IBAction func changeColor(_ sender: Any) {

        CATransaction.begin()
        CATransaction.setAnimationDuration(1)
        
        let red = CGFloat(arc4random_uniform(255)) / 256
        let green = CGFloat(arc4random_uniform(255)) / 256
        let blue = CGFloat(arc4random_uniform(255)) / 256
        self.colorLayer.backgroundColor = UIColor(red: red, green: green, blue: blue, alpha: 1).cgColor
        
        CATransaction.setCompletionBlock { 
            var transform = self.colorLayer.affineTransform()
            transform = transform.rotated(by:  CGFloat.pi / 2 )
            self.colorLayer.setAffineTransform(transform)
        }
        
        CATransaction.commit()
    }
```

> 注意:  
> 旋转动画要比颜色渐变快得多，这是因为完成块是在颜色渐变的事务提交并出栈之后才被执行，于是，用默认的事务做变换，默认的时间也就变成了0.25秒。
 

## 图层行为


直接对UIView关联的图层做动画:

```
class ViewController: UIViewController {

    @IBOutlet weak var layerView: UIView!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.layerView.layer.backgroundColor = UIColor.blue.cgColor
    }
    
    @IBAction func changeColor(_ sender: Any) {
        
        CATransaction.begin()
        CATransaction.setAnimationDuration(1)
        
        let red = CGFloat(arc4random_uniform(255)) / 256
        let green = CGFloat(arc4random_uniform(255)) / 256
        let blue = CGFloat(arc4random_uniform(255)) / 256
        self.layerView.layer.backgroundColor = UIColor(red: red, green: green, blue: blue, alpha: 1).cgColor
 
        CATransaction.commit()
    }
}
```

上面的例子中只是直接对`layerView`的关联层的背景色进行动画，执行发现图层的颜色没有动画而是直接变成修改后的颜色 **隐式动画好像被禁用了**。
### 行为
	我们把改变属性时 CALayer 自动应用的动画称作 行为


当 `CALayer` 的属性被修改的时候他会调用 `open func action(forKey event: String) -> CAAction?` 方法传递属性的名称。`forKey` 传递是是属性比如`backgroundColor `

行为的过程如下:   

- 图层首先检测他是否有代理，并是否实现了`CALayerDelegate`协议指定的 `public func action(for layer: CALayer, forKey event: String) -> CAAction?` 方法如果有直接调用并返回结果

- 如果没有代理或者代理方法没有实现 `public func action(for layer: CALayer, forKey event: String) -> CAAction?` 方法，图层接着检查包含属性名称对应行为映射的 `actions` 字典。

- 如果`actions`字典没有包含对象的属性，那么图层接着在他的`style`字典接着搜索属性名。

- 最后如果在`style`里面也找不到对应的行为，那么图层将会直接调用定义了每个属性的标准行为的`open class func defaultAction(forKey event: String) -> CAAction?`

经过如上过程 `open func action(forKey event: String) -> CAAction?` 返回结果: 

- **返回空**: 此时不会有动画
- **返回`CAAction`对象** 

CALayer拿这个结果根据先前和当前的值去做动画。

### 禁用原理 
每个 `UIView` 都是他关联层的代理，并且实现了`open func action(forKey event: String) -> CAAction?`方法。当不在一个动画块的实现中，UIView 对所有图层行为都返回nil，但是在`动画block`之内返回非空值。


下面demo实验 
 
```
class ViewController: UIViewController {
    
    var colorLayer: CALayer!
    
    @IBOutlet weak var layerView: UIView!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        print("Outside: \(String(describing: self.layerView.action(for: self.layerView.layer, forKey: "backgroundColor")))")
        
        UIView.beginAnimations(nil, context: nil)
        
        print("Inside: \(String(describing: self.layerView.action(for: self.layerView.layer, forKey: "backgroundColor")))")
        UIView.commitAnimations()
    }
```    

运行结果

```
Outside: Optional(<null>)
Inside: Optional(<CABasicAnimation:0x600000030260; delegate = <UIViewAnimationState: 0x7f83a61019c0>; fillMode = both; timingFunction = easeInEaseOut; duration = 0.2; fromValue = <CGColor 0x6180002a0240> [<CGColorSpace 0x60800002f2c0> (kCGColorSpaceICCBased; kCGColorSpaceModelRGB; sRGB IEC61966-2.1; extended range)] ( 0 0 1 1 ); keyPath = backgroundColor>)

```

###预言：
- 当属性在动画块之外发生改变，UIView直接通过返回nil来禁止隐式动画。
- 如果在动画块范围之内，根据动画具体类型返回相应的属性（这个例子就是`CABasicAnimation`）。

返回nil不是禁止隐式动画的唯一方法，

CATransacition有个方法叫`setDisableActions`可以用来对所有的属性打开或者禁止隐式动画。  
`CATransaction.begin()` 之后使用如下代码同样可以阻止动画发生

```
CATransaction.setDisableActions(true)
```

总结:

- UIView 管理层禁用隐式动画，对这个图层做动画的办法就是使用 UIView 的动画函数（不是依赖CATransaction）,或者继承UIView重写`open func action(forKey event: String) -> CAAction?` 

- 对于单独的图层通过实现`open func action(forKey event: String) -> CAAction?`的代理方法护照提供一个actions字典来控制隐式动画。


### 过渡
行为通常是一个被`Core Animation`隐式调用的显式动画对象，这里实现了一个`CATrasition`的实例，叫 **推进过渡**

```
class ViewController: UIViewController {
 
    var colorLayer: CALayer!
    
    @IBOutlet weak var layerView: UIView!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.colorLayer = CALayer()
        self.colorLayer.frame = CGRect(x: 50, y: 50, width: 100, height: 100)
        self.colorLayer.backgroundColor = UIColor.blue.cgColor
        
        let transition = CATransition()
        transition.type = kCATransitionPush
        transition.subtype = kCATransitionFromLeft
        self.colorLayer.actions = ["backgroundColor" : transition]
        
        self.layerView.layer.addSublayer(self.colorLayer)
    }

    @IBAction func changeColor(_ sender: Any) {
        
        let red = CGFloat(arc4random_uniform(255)) / 256
        let green = CGFloat(arc4random_uniform(255)) / 256
        let blue = CGFloat(arc4random_uniform(255)) / 256
        
        self.colorLayer.backgroundColor = UIColor(red: red, green: green, blue: blue, alpha: 1).cgColor
    }
}
```




## 呈现与模型

CALayer的属性行为其实很不正常，因为改变一个图层的属性并没有立刻改变而是通过一段时间渐变更新。
改变图层的一个属性，属性的值是立刻更新的但是屏幕上没有立刻改变，这是因为设置的属性并没有直接更新到UI，他只是定义了图层动画的变化。

设置CALayer的属性实际上是在定义当前事务结束之后图层如何显示的模型。`Core Animation`扮演了一个控制器的角色，并且负责根据图层行为和事务设置去不断更新视图的这些属性在屏幕上的状态。

CALayer是一个连接用户界面虚构的类，但是在界面本身这个场景下CALayer的行为更像是存储了视图如何显示和动画的数据模型。

在iOS中如果动画时长大于1/60秒，Core Animation 就需要再设置一次一次新值和新值生效之间，对屏幕上图层进行重新组织。这意味着CALayer除了真实值（你设置的值）之外，必须要知道当前显示在屏幕上属性值的记录。

每个图层属性的显示值都被存储在一个叫呈现树独立图层当中，他可以通过`presentation()`方法访问。这个呈现树实际是模型图层的复制，但是他的属性代表了在任何指定时刻当前外观效果.换句话说你可以通过呈现图层的值来获取当前屏幕上显示出来的值


呈现树通过图层树中所有图层的程序图层形成。注意呈现图层仅仅当图层首次被提交（第一次在屏幕上显示）的时候创建，所以在那之前调用presentation()返回nil。

你肯注意到一个modelLayer的方法，在呈现层上调用modelLayer将会返回他正在呈现所依赖的CALayer。通常在一个图层上调用modelLayer会返回self（实际上我们已经创建的原始图层就是一种数据模型）

大多数情况你不需要直接访问呈现图层，你可以通过和模型图层的交互来让Core Animation更新显示。两种情况下呈现图层会很有用一个是同步动画一个是处理用户交互。

- 如果你在实现一个基于定时器的动画，而不是仅仅基于事务的动画，这个时候准确的知道在某一时刻图层显示在什么位置就很有用。  
- 如果你想让你做的动画图层响应用户输入，你可以使用hitTest方法来判断指定图层是否被触摸，这个时候对呈现图层而不是模型图层调用hitTest会更有意义，因为呈现图层代表了用户当前看到的图层位置而不是当前动画结束之后的位置  



```
class ViewController: UIViewController {
 
    var colorLayer: CALayer!
 
    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.colorLayer = CALayer()
        self.colorLayer.frame = CGRect(x: 0, y: 0, width: 100, height: 100)
        self.colorLayer.position = CGPoint(x: self.view.bounds.width * 0.5, y: self.view.bounds.height * 0.5)
        self.colorLayer.backgroundColor = UIColor.blue.cgColor
        
        self.view.layer.addSublayer(self.colorLayer)
    }
    
    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        
        if
            let point = touches.first?.location(in: self.view),
            let preLayer = self.colorLayer!.presentation() {
            if preLayer.hitTest(point) != nil {
                let red = CGFloat(arc4random_uniform(255)) / 256
                let green = CGFloat(arc4random_uniform(255)) / 256
                let blue = CGFloat(arc4random_uniform(255)) / 256
                
                self.colorLayer.backgroundColor = UIColor(red: red, green: green, blue: blue, alpha: 1).cgColor
            } else {
                CATransaction.begin()
                CATransaction.setAnimationDuration(4)
                self.colorLayer.position = point
                CATransaction.commit()
            }
        }
    }
```    




 
在这个例子中，点击屏幕上任意位置会将图层平移到哪里，点击图层本身可以改变颜色。我们通过对呈现图层调用hitTest方法来判断是否被点击。
如果让hitTest直接作用colorLayer而不是呈现图层，你会发现当图层移动的时候他不能正确的工作。这时候你就需要点击图层将要移动到的位置而不是图层本身来响应点击（这就是用呈现图层来响应hit test的原因）。











