---
layout: post
title: 专用图层
date: 2016-02-16 15:32:24.000000000 +09:00
tags: 分类1
---

# 专用图层
 `CAShapeLayer` : 通过矢量而不是Bitmap来绘制图层，相比使用 `Core Graphics` 直接向CALayer的内容绘制路径有如下优势:  

- **渲染快速**。 由于 `CAShapeLayer` 使用了硬件加速，绘制同一个图形比 `Core Graphics` 快很多。  
- **高效使用内存**。 一个 `CAShapeLayer` 不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大都不会占用太多内存。
- **不会被图层边界裁剪**。一个 `CAShapeLayer` 可以在边界之外绘制，并且不会像使用 `Core Graphics` 的普通CALayer一样被裁剪。
- **不会出现像素化**。 当你给CAShapeLayer做3D变换它不像一个有寄宿图的普通图层一样变得像素化。

## 创建CGPath

CAShapeLayer 可以用来绘制所有能够通过 CGPath 来表示的形状。这个形状不一定要闭合，图层路径也不一定要不可破，事实上你可以在一个图层上绘制好几个不同的形状。
你可以控制一些属性比如   
(线宽，用点表示单位)， 
lineCap (线条结尾的样子)
(线条之间的结合点的样 子);
但是在图层层面你只有一次机会设置这些属性。

如果你想用不同颜色或风格来绘制多个形状，就不得不为每个形状准备一个图层了。


 CAShapeLayer 属性是   类型，但是我们用 UIBezierPath 帮助 类创建了图层路径，这样我们就不用考虑人工释放 了。图6.1是代码运行 的结果。虽然还不是很完美，但是总算知道了大意对吧!

```
    func shapLayer() {
        let path = UIBezierPath()
        
        path.move(to: CGPoint(x: 175, y: 100))
        path.addArc(withCenter: CGPoint(x: 150, y: 100), radius: 25, startAngle: 0, endAngle: CGFloat.pi * 2, clockwise: true)
        path.move(to: CGPoint(x:150, y:125))
        path.addLine(to:  CGPoint(x:150, y: 175))
        path.addLine(to: CGPoint(x:125, y: 225))
        path.move(to: CGPoint(x: 150, y: 175))
        path.addLine(to:  CGPoint(x:175, y: 225))
        path.move(to: CGPoint(x:100, y:150))
        path.addLine(to:  CGPoint(x:200, y:150))
        
        let shaperLayer = CAShapeLayer()
        shaperLayer.strokeColor = UIColor.red.cgColor
        shaperLayer.fillColor = UIColor.clear.cgColor
        shaperLayer.lineWidth = 5
        shaperLayer.lineCap = kCALineCapRound
        shaperLayer.lineJoin = kCALineJoinRound
        shaperLayer.path = path.cgPath
        self.view.layer.addSublayer(shaperLayer)
    }
```    

## 圆角
使用CAShapeLayer可以单独制定每个圆角。


```
func twoCorner() -> UIBezierPath {
    let rect = CGRect(x: 50, y: 50, width: 100, height: 100)
    let radii = CGSize(width: 20, height: 20)
 
    return UIBezierPath(roundedRect: rect, byRoundingCorners: [.topLeft, .topRight], cornerRadii: radii)
}
```    
我们可以通过这个图层路径绘制一个既有直角又有圆角的View。
如果我们想依照这个图形来裁剪View内容我们可以把CAShapeLayer作为视图的宿主图层，而不是添加一个值·子视图。


#CATextLayer
如果你想在一个图层里面显示文字，可以借助图层代理直接将字符串使用CoreGraphics写入图层内容。

CoreAnimation提供了一个CALayer的子类CATextLayer，它以图层的形式包含了UILabl几乎所有的绘制特性并且额外提供了一些新特性。CATextLayer使用了CoreText渲染速度很快。

















